import { Supernova } from "../../core/SDKSupernova";
import { TokenType } from "../../model/enums/SDKTokenType";
import { TokenGroup } from "../../model/groups/SDKTokenGroup";
import { Token } from "../../model/tokens/SDKToken";
export type TokenJSONBuilderOptions = {
    /** Conversion method to be used for token names. Original will use actual token name */
    naming: JSONBuilderNamingOption;
    /** When enabled, brandId will be included in every token */
    includeBrandId: boolean;
    /** When enabled, comments will be included in tokens that have description */
    includeComments: boolean;
    /** When provided, tokens will be filtered to only show tokens belonging to this brand */
    brandId: string | null;
    /** When enabled, type will be included in every token */
    includeType: boolean;
    /** When enabled, root category node will be generated. If type === null, multiple root nodes will be generated, one for each type */
    includeRootTypeNodes: boolean;
    /** When provided, only tokens of one category will be generated. Providing null will generate all tokens regardless of type */
    type: TokenType | null;
    /** When enabled, output will be split into multiple files. Ignored for now */
    multifile: boolean;
};
export type TokenJSONBuilderOptionsInternal = TokenJSONBuilderOptions & {
    consumerMode: ConsumerMode;
};
export declare enum JSONBuilderNamingOption {
    original = "original",
    camelcase = "camelcase",
    snakecase = "snakecase",
    kebabcase = "kebabcase"
}
declare enum ConsumerMode {
    styleDictionary = 0,
    figmaTokens = 1
}
/** JSON builder tooling object. Allows to build full token JSON definition for different styles of outputs, like Style Dictionary or Figma Tokens plugin */
export declare class TokenJSONBuilder {
    private instance;
    private version;
    private designSystemId;
    private versionId;
    private tokenTransformer;
    constructor(instance: Supernova, designSystemId: string, versionId: string);
    /** Fetches all tokens available for selected design system version, and converts them to style dictionary representation. */
    styleDictionaryRepresentation(options: TokenJSONBuilderOptions): Promise<{}>;
    /** Fetches all tokens available for selected design system version, and converts them to figma tokens representation. */
    figmaTokensRepresentation(isSingleFile: boolean): Promise<{}>;
    private buildTokenStructure;
    /** Generate style dictionary tree */
    private generateStyleDictionaryTree;
    /** Construct tree out of one specific group, independent of tree type */
    private representTree;
    /** Find all tokens that belong to a certain group and retrieve them as objects */
    static tokensOfGroup(containingGroup: TokenGroup, allTokens: Array<Token>): Array<Token>;
    /** Retrieve chain of groups up to a specified group, ordered from parent to children */
    static referenceGroupChain(containingGroup: TokenGroup, allGroups: Array<TokenGroup>): Array<TokenGroup>;
}
export {};
